import { sql } from "drizzle-orm";
import { check, foreignKey, index, uniqueIndex } from "drizzle-orm/pg-core";
import {
  boolean,
  integer,
  jsonb,
  pgTable,
  text,
  timestamp,
  varchar,
} from "drizzle-orm/pg-core";
import { idRef, idWithTag, withAuditRefs } from "./_common";
import { bizes } from "./bizes";
import { resources } from "./resources";
import { users } from "./users";
import { bookingOrders, fulfillmentUnits } from "./fulfillment";
import { noteStatusEnum, noteTargetTypeEnum, noteVisibilityEnum } from "./enums";
import { offers, offerVersions } from "./offers";
import { queueEntries } from "./queue";
import { transportTrips } from "./transportation";

/**
 * notes
 *
 * ELI5:
 * Annotation root table with explicit visibility classes.
 *
 * Visibility meaning:
 * - public: visible to normal operational users
 * - private: visible to restricted internal roles
 * - ai: generated by AI systems, usually internal
 * - system: generated by automations/workflows
 */
export const notes = pgTable(
  "notes",
  {
    /** Stable primary key. */
    id: idWithTag("note"),

    /** Tenant boundary. */
    bizId: idRef("biz_id")
      .references(() => bizes.id)
      .notNull(),

    /** Target discriminator. */
    targetType: noteTargetTypeEnum("target_type").notNull(),

    /** Target payload for booking order notes. */
    bookingOrderId: idRef("booking_order_id").references(() => bookingOrders.id),

    /** Target payload for fulfillment unit notes. */
    fulfillmentUnitId: idRef("fulfillment_unit_id").references(
      () => fulfillmentUnits.id,
    ),

    /** Target payload for resource notes. */
    resourceId: idRef("resource_id").references(() => resources.id),

    /** Target payload for offer notes. */
    offerId: idRef("offer_id").references(() => offers.id),

    /** Target payload for offer version notes. */
    offerVersionId: idRef("offer_version_id").references(() => offerVersions.id),

    /** Target payload for customer notes. */
    customerUserId: idRef("customer_user_id").references(() => users.id),

    /** Target payload for queue entry notes. */
    queueEntryId: idRef("queue_entry_id").references(() => queueEntries.id),

    /** Target payload for trip notes. */
    tripId: idRef("trip_id").references(() => transportTrips.id),

    /** Generic key for custom target mode. */
    customTargetKey: varchar("custom_target_key", { length: 240 }),

    /** Visibility class. */
    visibility: noteVisibilityEnum("visibility").default("private").notNull(),

    /** Note lifecycle. */
    status: noteStatusEnum("status").default("active").notNull(),

    /** Primary note body. */
    body: text("body").notNull(),

    /** Optional short title. */
    title: varchar("title", { length: 200 }),

    /** Note source type (user/ai/system/integration). */
    sourceType: varchar("source_type", { length: 40 }).default("user").notNull(),

    /** Optional source reference (model id, workflow id, integration id). */
    sourceRef: varchar("source_ref", { length: 200 }),

    /** Optional creator user pointer. */
    createdByUserId: idRef("created_by_user_id").references(() => users.id),

    /** Optional last editor user pointer. */
    editedByUserId: idRef("edited_by_user_id").references(() => users.id),

    /** Last edit timestamp. */
    editedAt: timestamp("edited_at", { withTimezone: true }),

    /** Pinned marker for important notes. */
    isPinned: boolean("is_pinned").default(false).notNull(),

    /** Soft lock marker to disallow regular editing. */
    isLocked: boolean("is_locked").default(false).notNull(),

    /** Running revision number. */
    revision: integer("revision").default(1).notNull(),

    /** Extension payload. */
    metadata: jsonb("metadata").default({}),

    /** Full audit metadata. */
    ...withAuditRefs(() => users.id),
  },
  (table) => ({
    notesBizIdIdUnique: uniqueIndex("notes_biz_id_id_unique").on(
      table.bizId,
      table.id,
    ),
    /** Composite key for tenant-safe child revision/override FKs. */

    /** Common retrieval path by target. */
    notesBizTargetIdx: index("notes_biz_target_idx").on(
      table.bizId,
      table.targetType,
      table.visibility,
      table.status,
    ),

    /** Tenant-safe FK to booking order. */
    notesBizBookingOrderFk: foreignKey({
      columns: [table.bizId, table.bookingOrderId],
      foreignColumns: [bookingOrders.bizId, bookingOrders.id],
      name: "notes_biz_booking_order_fk",
    }),

    /** Tenant-safe FK to fulfillment unit. */
    notesBizFulfillmentUnitFk: foreignKey({
      columns: [table.bizId, table.fulfillmentUnitId],
      foreignColumns: [fulfillmentUnits.bizId, fulfillmentUnits.id],
      name: "notes_biz_fulfillment_unit_fk",
    }),

    /** Tenant-safe FK to resource. */
    notesBizResourceFk: foreignKey({
      columns: [table.bizId, table.resourceId],
      foreignColumns: [resources.bizId, resources.id],
      name: "notes_biz_resource_fk",
    }),

    /** Tenant-safe FK to offer. */
    notesBizOfferFk: foreignKey({
      columns: [table.bizId, table.offerId],
      foreignColumns: [offers.bizId, offers.id],
      name: "notes_biz_offer_fk",
    }),

    /** Tenant-safe FK to offer version. */
    notesBizOfferVersionFk: foreignKey({
      columns: [table.bizId, table.offerVersionId],
      foreignColumns: [offerVersions.bizId, offerVersions.id],
      name: "notes_biz_offer_version_fk",
    }),

    /** Tenant-safe FK to queue entry. */
    notesBizQueueEntryFk: foreignKey({
      columns: [table.bizId, table.queueEntryId],
      foreignColumns: [queueEntries.bizId, queueEntries.id],
      name: "notes_biz_queue_entry_fk",
    }),

    /** Tenant-safe FK to trip. */
    notesBizTripFk: foreignKey({
      columns: [table.bizId, table.tripId],
      foreignColumns: [transportTrips.bizId, transportTrips.id],
      name: "notes_biz_trip_fk",
    }),

    /** Source type enum-by-check to keep controlled vocabulary. */
    notesSourceTypeCheck: check(
      "notes_source_type_check",
      sql`"source_type" IN ('user', 'ai', 'system', 'integration')`,
    ),

    /** Revision must remain positive. */
    notesRevisionCheck: check(
      "notes_revision_check",
      sql`"revision" >= 1`,
    ),

    /**
     * Target payload shape check by target type.
     * Exactly one target family is allowed per row.
     */
    notesTargetShapeCheck: check(
      "notes_target_shape_check",
      sql`
      (
        "target_type" = 'booking_order'
        AND "booking_order_id" IS NOT NULL
        AND "fulfillment_unit_id" IS NULL
        AND "resource_id" IS NULL
        AND "offer_id" IS NULL
        AND "offer_version_id" IS NULL
        AND "customer_user_id" IS NULL
        AND "queue_entry_id" IS NULL
        AND "trip_id" IS NULL
        AND "custom_target_key" IS NULL
      ) OR (
        "target_type" = 'fulfillment_unit'
        AND "booking_order_id" IS NULL
        AND "fulfillment_unit_id" IS NOT NULL
        AND "resource_id" IS NULL
        AND "offer_id" IS NULL
        AND "offer_version_id" IS NULL
        AND "customer_user_id" IS NULL
        AND "queue_entry_id" IS NULL
        AND "trip_id" IS NULL
        AND "custom_target_key" IS NULL
      ) OR (
        "target_type" = 'resource'
        AND "booking_order_id" IS NULL
        AND "fulfillment_unit_id" IS NULL
        AND "resource_id" IS NOT NULL
        AND "offer_id" IS NULL
        AND "offer_version_id" IS NULL
        AND "customer_user_id" IS NULL
        AND "queue_entry_id" IS NULL
        AND "trip_id" IS NULL
        AND "custom_target_key" IS NULL
      ) OR (
        "target_type" = 'offer'
        AND "booking_order_id" IS NULL
        AND "fulfillment_unit_id" IS NULL
        AND "resource_id" IS NULL
        AND "offer_id" IS NOT NULL
        AND "offer_version_id" IS NULL
        AND "customer_user_id" IS NULL
        AND "queue_entry_id" IS NULL
        AND "trip_id" IS NULL
        AND "custom_target_key" IS NULL
      ) OR (
        "target_type" = 'offer_version'
        AND "booking_order_id" IS NULL
        AND "fulfillment_unit_id" IS NULL
        AND "resource_id" IS NULL
        AND "offer_id" IS NULL
        AND "offer_version_id" IS NOT NULL
        AND "customer_user_id" IS NULL
        AND "queue_entry_id" IS NULL
        AND "trip_id" IS NULL
        AND "custom_target_key" IS NULL
      ) OR (
        "target_type" = 'customer'
        AND "booking_order_id" IS NULL
        AND "fulfillment_unit_id" IS NULL
        AND "resource_id" IS NULL
        AND "offer_id" IS NULL
        AND "offer_version_id" IS NULL
        AND "customer_user_id" IS NOT NULL
        AND "queue_entry_id" IS NULL
        AND "trip_id" IS NULL
        AND "custom_target_key" IS NULL
      ) OR (
        "target_type" = 'queue_entry'
        AND "booking_order_id" IS NULL
        AND "fulfillment_unit_id" IS NULL
        AND "resource_id" IS NULL
        AND "offer_id" IS NULL
        AND "offer_version_id" IS NULL
        AND "customer_user_id" IS NULL
        AND "queue_entry_id" IS NOT NULL
        AND "trip_id" IS NULL
        AND "custom_target_key" IS NULL
      ) OR (
        "target_type" = 'trip'
        AND "booking_order_id" IS NULL
        AND "fulfillment_unit_id" IS NULL
        AND "resource_id" IS NULL
        AND "offer_id" IS NULL
        AND "offer_version_id" IS NULL
        AND "customer_user_id" IS NULL
        AND "queue_entry_id" IS NULL
        AND "trip_id" IS NOT NULL
        AND "custom_target_key" IS NULL
      ) OR (
        "target_type" = 'custom'
        AND "booking_order_id" IS NULL
        AND "fulfillment_unit_id" IS NULL
        AND "resource_id" IS NULL
        AND "offer_id" IS NULL
        AND "offer_version_id" IS NULL
        AND "customer_user_id" IS NULL
        AND "queue_entry_id" IS NULL
        AND "trip_id" IS NULL
        AND "custom_target_key" IS NOT NULL
      )
      `,
    ),
  }),
);

/**
 * note_revisions
 *
 * ELI5:
 * Immutable revision history for note content edits.
 */
export const noteRevisions = pgTable(
  "note_revisions",
  {
    /** Stable primary key. */
    id: idWithTag("note_revision"),

    /** Tenant boundary. */
    bizId: idRef("biz_id")
      .references(() => bizes.id)
      .notNull(),

    /** Parent note. */
    noteId: idRef("note_id")
      .references(() => notes.id)
      .notNull(),

    /** Monotonic revision number for this note. */
    revision: integer("revision").notNull(),

    /** Full note body at this revision. */
    body: text("body").notNull(),

    /** Optional normalized diff from previous revision. */
    diff: jsonb("diff"),

    /** Editor user id if human-edited. */
    editedByUserId: idRef("edited_by_user_id").references(() => users.id),

    /** Edit timestamp. */
    editedAt: timestamp("edited_at", { withTimezone: true }).defaultNow().notNull(),

    /** Optional edit reason. */
    reason: varchar("reason", { length: 500 }),

    /** Full audit metadata. */
    ...withAuditRefs(() => users.id),
  },
  (table) => ({
    noteRevisionsBizIdIdUnique: uniqueIndex("note_revisions_biz_id_id_unique").on(
      table.bizId,
      table.id,
    ),
    /** One row per revision number per note. */
    noteRevisionsUnique: uniqueIndex("note_revisions_unique").on(
      table.noteId,
      table.revision,
    ),

    /** Common revision history path. */
    noteRevisionsBizNoteRevisionIdx: index("note_revisions_biz_note_revision_idx").on(
      table.bizId,
      table.noteId,
      table.revision,
    ),

    /** Tenant-safe FK to note. */
    noteRevisionsBizNoteFk: foreignKey({
      columns: [table.bizId, table.noteId],
      foreignColumns: [notes.bizId, notes.id],
      name: "note_revisions_biz_note_fk",
    }),

    /** Revision should be positive. */
    noteRevisionsRevisionCheck: check(
      "note_revisions_revision_check",
      sql`"revision" >= 1`,
    ),
  }),
);

/**
 * note_access_overrides
 *
 * ELI5:
 * Optional per-user exceptions for note access beyond visibility defaults.
 */
export const noteAccessOverrides = pgTable(
  "note_access_overrides",
  {
    /** Stable primary key. */
    id: idWithTag("note_acl"),

    /** Tenant boundary. */
    bizId: idRef("biz_id")
      .references(() => bizes.id)
      .notNull(),

    /** Note receiving override. */
    noteId: idRef("note_id")
      .references(() => notes.id)
      .notNull(),

    /** User receiving explicit override. */
    userId: idRef("user_id")
      .references(() => users.id)
      .notNull(),

    /** Explicit read grant/deny. */
    canRead: boolean("can_read").default(true).notNull(),

    /** Explicit edit grant/deny. */
    canEdit: boolean("can_edit").default(false).notNull(),

    /** Optional override expiry. */
    expiresAt: timestamp("expires_at", { withTimezone: true }),

    /** Optional reason for override. */
    reason: varchar("reason", { length: 500 }),

    /** Full audit metadata. */
    ...withAuditRefs(() => users.id),
  },
  (table) => ({
    noteAccessOverridesBizIdIdUnique: uniqueIndex("note_access_overrides_biz_id_id_unique").on(
      table.bizId,
      table.id,
    ),
    /** One active override per note-user pair. */
    noteAccessOverridesUnique: uniqueIndex("note_access_overrides_unique").on(
      table.noteId,
      table.userId,
    ),

    /** Access lookup path. */
    noteAccessOverridesBizUserIdx: index("note_access_overrides_biz_user_idx").on(
      table.bizId,
      table.userId,
      table.expiresAt,
    ),

    /** Tenant-safe FK to note. */
    noteAccessOverridesBizNoteFk: foreignKey({
      columns: [table.bizId, table.noteId],
      foreignColumns: [notes.bizId, notes.id],
      name: "note_access_overrides_biz_note_fk",
    }),

    /** Expiry must be in the future relative to creation when present. */
    noteAccessOverridesExpiryCheck: check(
      "note_access_overrides_expiry_check",
      sql`"expires_at" IS NULL OR "expires_at" > "created_at"`,
    ),
  }),
);
